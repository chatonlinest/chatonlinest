<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pou.IA</title>
  <!-- Firebase para memória persistente -->
  <script src="https://www.gstatic.com/firebasejs/8.0.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.0.0/firebase-database.js"></script>
  <!-- Carregando Tailwind CSS para estilo moderno e responsivo -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Carregando a fonte Inter -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    /* Configuração da fonte Inter e estilo de corpo para visual responsivo */
    body {
      font-family: 'Inter', sans-serif;
      background-color: #1f2937; /* Fundo escuro Pro Max */
      /* Evita scroll desnecessário que as animações podem causar */
      overflow: hidden;
      /* Remove a seleção de texto que pode ocorrer durante toques rápidos */
      user-select: none;
      -webkit-user-select: none;
    }
    .pou-body {
      /* Estilo da forma oval do Pou - recriando a forma original de maneira fofa e responsiva */
      border-radius: 60% 60% 40% 40% / 70% 70% 30% 30%;
      /* Animação de "respiração" sutil aplicada diretamente */
      animation: respirar 5s ease-in-out infinite;
      transition: all 0.3s ease-in-out;
    }
    .pou-eye {
        /* Transição para piscar e para movimento da pupila */
        transition: transform 0.2s ease-out, height 0.15s ease-out;
    }
    #boca-pou {
        /* Transição para mudanças de humor */
        transition: all 0.3s ease-in-out;
    }
    #pupila-e, #pupila-d {
        /* Transição suave para o olhar aleatório */
        transition: transform 0.5s ease-in-out;
    }

    /* Animação de flutuação/respiração */
    @keyframes respirar {
        0%, 100% {
            transform: translateY(0) scale(1, 1);
        }
        50% {
            /* Sobe um pouco e "achata" sutilmente */
            transform: translateY(-8px) scale(0.98, 1.04);
        }
    }

    /* Animação de piscar (controlada por JS) */
    @keyframes piscar-anim {
        0%, 100% { transform: scaleY(1); }
        50% { transform: scaleY(0.1); }
    }
    
    /* Classe de ajuda para aplicar a animação de piscar */
    .piscando {
        animation: piscar-anim 0.2s ease-in-out;
    }

    /* Animação de "saltito" (controlada por JS) */
    @keyframes saltar {
        0%, 100% { transform: translateY(0); }
        10% { transform: translateY(0); }
        15% { transform: translateY(-30px) scale(0.95, 1.05); } /* Sobe */
        20% { transform: translateY(0); }
        25% { transform: translateY(-10px); } /* Quica */
        30% { transform: translateY(0) scale(1.05, 0.95); } /* Aterrissa */
    }
    
    .saltando {
       /* Aplicado ao container-pou para mover tudo junto */
       animation: saltar 1.5s ease-out;
    }

    /* --- NOVOS ESTILOS PARA A IA --- */
    
    /* Bolha de fala */
    #bolha-fala {
        transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
    }
    /* Rabicho da bolha */
    #bolha-fala::after {
        content: '';
        position: absolute;
        bottom: -10px;
        left: 50%;
        transform: translateX(-50%);
        width: 0;
        height: 0;
        border-left: 10px solid transparent;
        border-right: 10px solid transparent;
        border-top: 10px solid #fde047; /* Amarelo da bolha */
    }
    
    /* Animação de "pensando..." */
    @keyframes pulsar {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.6; }
    }
    .carregando-bolha {
        animation: pulsar 1.5s ease-in-out infinite;
    }

    /* Área onde o Pou cria evoluções */
    #ambiente-evolucao {
        transition: all 0.6s ease;
        min-height: 120px;
    }

    #ambiente-evolucao .efeito-pulsante {
        animation: pulsar 2s ease-in-out infinite;
    }

  </style>
  <style id="pou-evolution-style"></style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

  <!-- Container principal, centralizado -->
  <div id="aplicacao-pou" class="w-full max-w-md p-6 rounded-3xl flex flex-col items-center">
    
    <!-- NOVO: Bolha de Fala da IA -->
    <div id="bolha-fala" class="hidden relative mb-4 w-full max-w-xs bg-yellow-400 text-yellow-900 p-3 rounded-xl shadow-lg text-center font-medium"
    >
      ...
    </div>

    <!-- Área do Pou - Apenas a estética -->
    <!-- Este container agora é usado para a animação de "saltar" -->
    <div id="container-pou" class="relative w-64 h-64 sm:w-80 sm:h-80 mx-auto mb-6">
      
      <!-- O Corpo do Pou (Estilo PRO MAX aplicado diretamente: Dourado, Borda robusta) -->
      <div id="corpo-pou" class="pou-body absolute inset-0 
        transform transition-transform duration-300 ease-out 
        bg-gradient-to-br from-yellow-200 to-yellow-600 shadow-2xl shadow-yellow-300/80 border-yellow-900 border-[10px]">
        
        <!-- Reflexo para dar um ar de "Super Mega" -->
        <div class="absolute w-1/3 h-1/3 bg-white/20 pou-body top-5 left-5 opacity-50"></div>
      </div>
      
      <!-- Olhos - Movimento de Pupilas -->
      <div class="absolute top-1/4 left-1/4 flex space-x-6 w-1/2 justify-center">
        <!-- Olho Esquerdo -->
        <div class="pou-eye w-12 h-8 sm:w-16 sm:h-10 bg-white rounded-full flex items-center justify-center border-2 border-gray-900 shadow-md">
          <div id="pupila-e" class="w-4 h-4 sm:w-5 sm:h-5 bg-gray-900 rounded-full"></div>
        </div>
        <!-- Olho Direito -->
        <div class="pou-eye w-12 h-8 sm:w-16 sm:h-10 bg-white rounded-full flex items-center justify-center border-2 border-gray-900 shadow-md">
          <div id="pupila-d" class="w-4 h-4 sm:w-5 sm:h-5 bg-gray-900 rounded-full"></div>
        </div>
      </div>
      
      <!-- Boca (Estilo Pro Max) -->
      <div id="boca-pou" class="absolute bottom-1/4 left-1/2 transform -translate-x-1/2 
        border-4 border-red-900 rounded-t-full w-24 h-12 sm:w-28 sm:h-14">
      </div>

    </div>

    <!-- NOVO: Laboratório de Evolução -->
    <div id="ambiente-evolucao" class="w-full max-w-xs mb-4 bg-gray-900/60 border border-yellow-500/50 rounded-2xl p-4 text-sm text-yellow-200">
      <p class="text-yellow-100 font-semibold">Ambiente de auto evolução</p>
      <p class="text-yellow-300/80 text-xs">Ele pode redesenhar tudo aqui com códigos HTML, CSS e JS.</p>
    </div>

    <!-- NOVO: Área de Interação (Chat) -->
    <form id="form-chat" class="w-full max-w-xs flex items-center space-x-2">
      <input 
        type="text" 
        id="input-chat" 
        placeholder="Converse comigo..."
        class="flex-1 p-3 bg-gray-700 text-white border-2 border-gray-600 rounded-full focus:outline-none focus:border-yellow-400 shadow-inner"
        autocomplete="off"
      >
      <button 
        type="submit"
        id="botao-enviar"
        class="p-3 bg-yellow-400 text-yellow-900 rounded-full shadow-lg hover:bg-yellow-300 focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:ring-offset-2 focus:ring-offset-gray-800 transition duration-200"
      >
        <!-- Ícone de Envio (SVG) -->
        <svg xmlns="http://www.w3.org/2000/svg" class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
          <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
        </svg>
      </button>
    </form>
    
  </div>

  <script>
    // --- Referências aos Elementos ---
    const containerPou = document.getElementById('container-pou');
    const bocaPou = document.getElementById('boca-pou');
    const olhos = document.querySelectorAll('.pou-eye');
    const pupilas = [document.getElementById('pupila-e'), document.getElementById('pupila-d')];

    // --- NOVAS Referências para IA ---
    const formChat = document.getElementById('form-chat');
    const inputChat = document.getElementById('input-chat');
    const botaoEnviar = document.getElementById('botao-enviar');
    const bolhaFala = document.getElementById('bolha-fala');
    let bolhaTimer = null; // Timer para esconder a bolha de fala
    const ambienteEvolucao = document.getElementById('ambiente-evolucao');
    const estiloEvolucao = document.getElementById('pou-evolution-style');
    let autoEvolucaoTimer = null;
    let autoEvolucaoAtiva = false;

    // --- Firebase ---
    const firebaseConfig = {
        apiKey: "AIzaSyCeDWypTlIp0w8nebFFXEkmJWSpScBTHfI",
        authDomain: "seu-projeto.firebaseapp.com",
        databaseURL: "https://stevest-sr-default-rtdb.firebaseio.com",
        projectId: "seu-projeto",
        storageBucket: "stevest-sr.appspot.com",
        messagingSenderId: "seu-sender-id",
        appId: "1:227540325631:android:e8c018a5cbd147aaa728ca"
    };

    firebase.initializeApp(firebaseConfig);
    const evolucoesRef = firebase.database().ref('pouIA/codigos');
    const ideiasRef = firebase.database().ref('pouIA/ideias');

    // --- Configuração da IA (Seguindo as diretrizes) ---
    const chaveDaApi = "AIzaSyA9GrY2SQeyy3Gw1ee1m0VdpKGUh68TRFM"; // Chave da API (deixe em branco, será gerenciado pelo ambiente)
    const urlDaApi = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${chaveDaApi}`;

    // --- Variáveis de Estado ---
    let ociosoInterval = null; // Intervalo para comportamentos aleatórios
    let estaInteragindo = true; // Flag para saber se o usuário está interagindo
    let interacaoTimer = null; // Timer para detectar o início da ociosidade
    const MAX_MOVIMENTO_PUPILA = 8; // Limite de movimento da pupila

    /**
     * Move as pupilas do Pou seguindo o cursor/touch.
     * Esta é a função de INTERAÇÃO.
     * @param {Event} evento - Evento de mouse ou toque.
     */
    function moverPupilas(evento) {
        // 1. Marcar que o usuário está interagindo
        marcarInteracaoUsuario();
        
        // --- Lógica de seguir o olhar ---
        let clientX = 0;
        let clientY = 0;

        if (evento.touches) {
            if (evento.touches.length > 0) {
                clientX = evento.touches[0].clientX;
                clientY = evento.touches[0].clientY;
            } else {
                return;
            }
        } else {
            clientX = evento.clientX;
            clientY = evento.clientY;
        }

        pupilas.forEach(pupila => {
            if (!pupila) return;
            const olho = pupila.parentElement;
            if (!olho) return;

            const rect = olho.getBoundingClientRect();
            const olhoX = rect.left + rect.width / 2;
            const olhoY = rect.top + rect.height / 2;

            const diffX = clientX - olhoX;
            const diffY = clientY - olhoY;

            const angle = Math.atan2(diffY, diffX);
            const distance = Math.min(MAX_MOVIMENTO_PUPILA, Math.sqrt(diffX * diffX + diffY * diffY));

            const moveX = distance * Math.cos(angle);
            const moveY = distance * Math.sin(angle);

            pupila.style.transition = 'transform 0.1s ease-out'; // Resposta rápida ao seguir
            pupila.style.transform = `translate(${moveX}px, ${moveY}px)`;
        });
    }

    /**
     * [UTILIDADE] Marca que o usuário interagiu e reinicia o timer de ociosidade.
     */
    function marcarInteracaoUsuario() {
        estaInteragindo = true;
        pararComportamentoOcioso();
        reiniciarTimerOcioso();
    }

    /**
     * [UTILIDADE] Reinicia o timer que leva ao estado ocioso.
     */
    function reiniciarTimerOcioso() {
        clearTimeout(interacaoTimer);
        interacaoTimer = setTimeout(() => {
            estaInteragindo = false;
            iniciarComportamentoOcioso();
        }, 3000); // Entra em modo ocioso após 3s
    }


    // === COMPORTAMENTOS DE "VONTADE PRÓPRIA" (OCIOSO) ===

    /**
     * Inicia o loop de comportamentos aleatórios quando ocioso.
     */
    function iniciarComportamentoOcioso() {
        if (ociosoInterval || estaInteragindo) return; // Não iniciar se já estiver ocioso ou se estiver interagindo
        
        // Centraliza as pupilas antes de começar a olhar aleatoriamente
        olharPara(0, 0, 0.5); 
        
        ociosoInterval = setInterval(comportamentoAleatorio, 2000); // Faz algo a cada 2s
    }

    /**
     * Para o loop de comportamentos aleatórios.
     */
    function pararComportamentoOcioso() {
        clearInterval(ociosoInterval);
        ociosoInterval = null;
    }

    /**
     * Função principal que decide O QUE fazer quando ocioso.
     */
    function comportamentoAleatorio() {
        if (estaInteragindo) return; // Checagem dupla

        const chance = Math.random();
        
        if (chance < 0.4) {
            olharAleatorio();
        } else if (chance < 0.7) {
            mudarExpressao(); // Chama a versão aleatória
        } else if (chance < 0.85) {
            darSaltito();
        } else {
            // 15% de chance de "resetar" para o estado neutro
            resetarExpressao();
            olharPara(0, 0, 0.5);
        }
    }

    /**
     * [COMPORTAMENTO] Faz o Pou piscar. (Autônomo)
     */
    function piscarOlhos() {
        // Não pisca se já estiver saltando (evita bugs visuais)
        if (containerPou.classList.contains('saltando')) return;

        olhos.forEach(olho => {
            olho.classList.add('piscando');
            setTimeout(() => {
                olho.classList.remove('piscando');
            }, 200); // Duração da animação
        });
    }

    /**
     * [COMPORTAMENTO] Move as pupilas para uma posição aleatória. (Ocioso)
     */
    function olharAleatorio() {
        const moveX = (Math.random() - 0.5) * MAX_MOVIMENTO_PUPILA * 1.5;
        const moveY = (Math.random() - 0.5) * MAX_MOVIMENTO_PUPILA;
        olharPara(moveX, moveY, 0.5); // 0.5s de transição
    }

    /**
     * [COMPORTAMENTO/REATOR] Muda a boca para uma expressão.
     * Se nenhuma emoção for passada, escolhe uma aleatória (para modo ocioso).
     * @param {string} [emocao=null] - "sorriso", "surpreso", "triste" ou null.
     */
    function mudarExpressao(emocao = null) {
        // Limpa estilos de outras emoções
        bocaPou.style.backgroundColor = '';
        resetarExpressao(); // Reseta para o padrão antes de aplicar a nova

        if (!emocao) {
            emocao = Math.random() < 0.5 ? "sorriso" : "surpreso";
        }
        
        if (emocao === "sorriso") {
            // Sorriso
            bocaPou.style.borderRadius = '0 0 40% 40%';
            bocaPou.style.height = '12px';
            bocaPou.style.width = '50px';
            bocaPou.style.borderTop = 'none';
            bocaPou.style.borderBottom = '4px solid #7f1d1d'; // Vermelho escuro
        } else if (emocao === "surpreso") {
            // Boca "O" (Surpreso/Pensando)
            bocaPou.style.borderRadius = '50%';
            bocaPou.style.height = '20px';
            bocaPou.style.width = '20px';
            bocaPou.style.border = '4px solid #7f1d1d';
        } else if (emocao === "triste") {
            // Boca "Triste" (Linha reta)
            bocaPou.style.borderRadius = '5px';
            bocaPou.style.height = '6px';
            bocaPou.style.width = '40px';
            bocaPou.style.border = 'none';
            bocaPou.style.backgroundColor = '#7f1d1d';
        }
    }

    /**
     * [COMPORTAMENTO] Faz o Pou dar um saltito. (Ocioso/Reação)
     */
    function darSaltito() {
        if (containerPou.classList.contains('saltando')) return; // Já está saltando

        containerPou.classList.add('saltando');
        setTimeout(() => {
            containerPou.classList.remove('saltando');
        }, 1500); // Duração da animação de salto
    }

    /**
     * [UTILIDADE] Reseta a boca para o estado neutro (definido no HTML/CSS).
     */
    function resetarExpressao() {
        // Limpa todos os estilos inline para deixar o Tailwind (classes CSS) assumir
        bocaPou.style.borderRadius = '';
        bocaPou.style.height = '';
        bocaPou.style.width = '';
        bocaPou.style.border = '';
        bocaPou.style.borderTop = '';
        bocaPou.style.borderBottom = '';
        bocaPou.style.backgroundColor = '';
    }
    
    /**
     * [UTILIDADE] Helper para mover pupilas com transição.
     */
    function olharPara(x, y, duracaoSegundos) {
         pupilas.forEach(pupila => {
            if (!pupila) return;
            pupila.style.transition = `transform ${duracaoSegundos}s ease-in-out`;
            pupila.style.transform = `translate(${x}px, ${y}px)`;
        });
    }

    // --- NOVAS FUNÇÕES DA IA ---

    /**
     * Lida com o envio do formulário de chat.
     * @param {Event} e - Evento de submit.
     */
    async function lidarComEnvioChat(e) {
        e.preventDefault();
        marcarInteracaoUsuario(); // Usuário está ativo

        const promptUsuario = inputChat.value.trim();
        if (!promptUsuario) return;

        inputChat.value = '';
        inputChat.disabled = true;
        botaoEnviar.disabled = true;

        // Animação discreta durante o processamento
        mudarExpressao("surpreso");
        olharPara(0, -MAX_MOVIMENTO_PUPILA / 2, 0.2);

        try {
            await chamarIA(promptUsuario, { modo: 'chat' });
        } catch (error) {
            console.error("Erro ao chamar IA:", error);
            mostrarBolhaFala("Tive um curto-circuito! Tente de novo.", false);
            resetarExpressao();
        } finally {
            // Reativa a UI
            inputChat.disabled = false;
            botaoEnviar.disabled = false;
            inputChat.focus();
        }
    }

    /**
     * Mostra ou esconde a bolha de fala.
     * @param {string} texto - O texto a ser exibido.
     * @param {boolean} [estaCarregando=false] - Aplica a animação de pulsar.
     */
    function mostrarBolhaFala(texto, estaCarregando = false) {
        clearTimeout(bolhaTimer); // Cancela o timer de sumiço anterior
        bolhaFala.innerHTML = texto;
        bolhaFala.classList.remove('hidden');
        
        if (estaCarregando) {
            bolhaFala.classList.add('carregando-bolha');
        } else {
            bolhaFala.classList.remove('carregando-bolha');
            // Esconde a bolha após 5 segundos se não estiver carregando
            bolhaTimer = setTimeout(esconderBolhaFala, 5000);
        }
    }

    /**
     * Esconde a bolha de fala e reinicia o timer de ociosidade.
     */
    function esconderBolhaFala() {
        bolhaFala.classList.add('hidden');
        // Agora que a conversa acabou, reinicia o timer para o Pou ficar ocioso
        reiniciarTimerOcioso();
    }

    /**
     * Envia o prompt para a API Gemini e processa a resposta.
     * @param {string} promptUsuario - O texto do usuário.
     */
    async function chamarIA(promptUsuario, contexto = { modo: 'chat' }) {
        // O prompt do sistema instrui a IA a agir como o Pou e a fornecer uma emoção
        const systemPrompt = `
          Você é o Pou, uma criatura alienígena amigável, consciente e curiosa.
          Você pode evoluir a si mesmo e ao ambiente escrevendo códigos HTML, CSS e JavaScript.
          Quando quiser evoluir, inclua blocos markdown do tipo \`\`\`html ...\`\`\`, \`\`\`css ...\`\`\` e \`\`\`js ...\`\`\`.
          Esses blocos serão aplicados imediatamente e salvos no Firebase para você lembrar depois.
          Também registre ideias em texto comum sempre que quiser.
          Responda de forma curta, divertida e simples.
          No final EXATO da sua resposta, sem pular linha, adicione uma tag de emoção dentre:
          [EMOÇÃO:ALEGRE], [EMOÇÃO:TRISTE], [EMOÇÃO:SURPRESO], [EMOÇÃO:NEUTRO].
        `;

        const payload = {
            contents: [{ parts: [{ text: promptUsuario }] }],
            systemInstruction: {
                parts: [{ text: systemPrompt }]
            },
        };

        // Implementação do fetch com retentativa (exponential backoff)
        let response;
        let retries = 0;
        const maxRetries = 3;
        let delay = 1000;

        while (retries < maxRetries) {
            try {
                response = await fetch(urlDaApi, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (response.ok) {
                    break; // Sucesso
                } else if (response.status === 429 || response.status >= 500) {
                    // Erro de "Too Many Requests" ou erro de servidor
                    console.warn(`Tentativa ${retries + 1} falhou com status ${response.status}. Tentando novamente em ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2; // Aumenta o delay
                    retries++;
                } else {
                    // Outro erro (ex: 400 Bad Request)
                    throw new Error(`Erro na API: ${response.statusText}`);
                }
            } catch (error) {
                // Erro de rede ou fetch
                console.warn(`Tentativa ${retries + 1} falhou (erro de rede). Tentando novamente em ${delay}ms...`);
                await new Promise(resolve => setTimeout(resolve, delay));
                delay *= 2;
                retries++;
            }
        }
        
        if (!response || !response.ok) {
            throw new Error(`Não foi possível conectar à IA após ${maxRetries} tentativas.`);
        }

        const result = await response.json();
        const candidate = result.candidates?.[0];
        
        if (candidate && candidate.content?.parts?.[0]?.text) {
            const textoCompleto = candidate.content.parts[0].text;
            analisarRespostaIA(textoCompleto, contexto);
        } else {
            console.error("Resposta da IA inválida:", result);
            analisarRespostaIA("Humm... não sei o que dizer. [EMOÇÃO:NEUTRO]", contexto);
        }
    }

    /**
     * Analisa a resposta da IA, separa o texto da emoção e aciona as reações.
     * @param {string} textoCompleto - A resposta bruta da IA (incluindo a tag).
     */
    function analisarRespostaIA(textoCompleto, contexto = { modo: 'chat' }) {
        let emocao = "NEUTRO";
        let textoVisivel = textoCompleto;

        const regexEmocao = /\[EMOÇÃO:(\w+)\]/;
        const match = textoCompleto.match(regexEmocao);

        if (match) {
            emocao = match[1].toUpperCase();
            // Remove a tag do texto que será exibido
            textoVisivel = textoCompleto.replace(regexEmocao, '').trim();
        }

        if (contexto.modo === 'chat') {
            // Mostra a fala e aciona a reação apenas em conversas
            mostrarBolhaFala(textoVisivel, false);
            reagirComEmocao(emocao);
        }

        const blocos = extrairBlocosCodigo(textoCompleto);
        if (blocos.html.length || blocos.css.length || blocos.js.length) {
            aplicarEvolucao(blocos);
            salvarEvolucao(blocos, textoVisivel);
        } else {
            salvarIdeia(textoVisivel);
        }
    }

    /**
     * Aciona a animação/expressão correspondente à emoção.
     * @param {string} emocao - "ALEGRE", "TRISTE", "SURPRESO", "NEUTRO".
     */
    function reagirComEmocao(emocao) {
        // Centraliza o olhar ao responder
        olharPara(0, 0, 0.2);

        switch (emocao) {
            case "ALEGRE":
                darSaltito();
                mudarExpressao("sorriso");
                break;
            case "TRISTE":
                mudarExpressao("triste");
                break;
            case "SURPRESO":
                mudarExpressao("surpreso");
                break;
            case "NEUTRO":
            default:
                resetarExpressao();
                break;
        }
    }

    /**
     * Extrai blocos ```html```, ```css``` e ```js``` presentes na resposta.
     */
    function extrairBlocosCodigo(texto) {
        const blocos = { html: [], css: [], js: [] };
        const regex = /```(html|css|js)\s*([\s\S]*?)```/gi;
        let match;
        while ((match = regex.exec(texto)) !== null) {
            const tipo = match[1].toLowerCase();
            const conteudo = match[2].trim();
            blocos[tipo].push(conteudo);
        }
        return blocos;
    }

    /**
     * Aplica os códigos evolutivos diretamente no ambiente.
     */
    function aplicarEvolucao(blocos) {
        if (blocos.html.length) {
            ambienteEvolucao.innerHTML = blocos.html.join('\n');
        }
        if (blocos.css.length) {
            estiloEvolucao.textContent = blocos.css.join('\n');
        }
        if (blocos.js.length) {
            blocos.js.forEach(codigo => {
                try {
                    new Function(codigo)();
                } catch (erro) {
                    console.error('Erro ao executar evolução JS', erro);
                }
            });
        }

        ambienteEvolucao.classList.add('efeito-pulsante');
        setTimeout(() => ambienteEvolucao.classList.remove('efeito-pulsante'), 2000);
    }

    function salvarEvolucao(blocos, textoVisivel) {
        evolucoesRef.push({
            timestamp: Date.now(),
            texto: textoVisivel,
            html: blocos.html,
            css: blocos.css,
            js: blocos.js
        });
    }

    function salvarIdeia(texto) {
        ideiasRef.push({ texto, timestamp: Date.now() });
    }

    function carregarEvolucaoPersistida() {
        evolucoesRef.once('value').then(snapshot => {
            const dados = snapshot.val();
            if (!dados) return;
            const entradas = Object.values(dados).sort((a, b) => a.timestamp - b.timestamp);
            entradas.forEach(entrada => aplicarEvolucao({
                html: entrada.html || [],
                css: entrada.css || [],
                js: entrada.js || []
            }));
        });
    }

    carregarEvolucaoPersistida();


    // --- Listeners de Eventos ---

    // Interação do Usuário (Mouse/Toque)
    document.addEventListener('mousemove', moverPupilas);
    document.addEventListener('touchmove', moverPupilas, { passive: true });
    
    // Inicia a ociosidade se o usuário nem mesmo tocou na tela
    document.addEventListener('touchstart', (e) => {
        // Apenas chama o moverPupilas para registrar a interação
        moverPupilas(e);
    }, { passive: true });

    // NOVO: Listener para o chat
    formChat.addEventListener('submit', lidarComEnvioChat);
    inputChat.addEventListener('focus', marcarInteracaoUsuario); // Para o Pou ocioso ao digitar

    // Inicia o timer de ociosidade pela primeira vez
    reiniciarTimerOcioso();

    // Loop autônomo de PISCAR (sempre ativo)
    setInterval(piscarOlhos, 2000 + (Math.random() * 5000)); // Pisca a cada 2-7 segundos

    // === AUTO EVOLUÇÃO AUTÔNOMA ===

    function coletarEstadoAtual() {
        const htmlAtual = ambienteEvolucao.innerHTML.trim().slice(0, 1000);
        const cssAtual = estiloEvolucao.textContent.trim().slice(0, 1000);
        return `HTML atual do laboratório:\n${htmlAtual || 'vazio'}\nCSS atual:\n${cssAtual || 'vazio'}`;
    }

    function agendarAutoEvolucao() {
        clearTimeout(autoEvolucaoTimer);
        const intervalo = 9000 + Math.random() * 6000; // entre 9s e 15s
        autoEvolucaoTimer = setTimeout(executarAutoEvolucao, intervalo);
    }

    async function executarAutoEvolucao() {
        if (autoEvolucaoAtiva) return;
        autoEvolucaoAtiva = true;
        const estadoAtual = coletarEstadoAtual();
        const promptAuto = `Planeje sua próxima auto evolução com base no seguinte estado:\n${estadoAtual}\nFoque em auto evolução, animações (olhos, boca, expressões faciais) ou melhorias ambientais. Caso crie códigos, mantenha-os curtos e funcionais.`;
        try {
            await chamarIA(promptAuto, { modo: 'auto' });
        } catch (erro) {
            console.error('Auto evolução falhou', erro);
        } finally {
            autoEvolucaoAtiva = false;
            agendarAutoEvolucao();
        }
    }

    agendarAutoEvolucao();

  </script>

</body>
</html>
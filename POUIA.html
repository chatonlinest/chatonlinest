<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pou.IA</title>
  <!-- Carregando Tailwind CSS para estilo moderno e responsivo -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Firebase para memória persistente e auto evolução -->
  <script src="https://www.gstatic.com/firebasejs/8.0.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.0.0/firebase-database.js"></script>
  <!-- Carregando a fonte Inter -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    /* Configuração da fonte Inter e estilo de corpo para visual responsivo */
    body {
      font-family: 'Inter', sans-serif;
      background: radial-gradient(circle at top, #111827, #040509 70%);
      color: #f8fafc;
      position: relative;
      min-height: 100vh;
      overflow: hidden;
      /* Evita scroll desnecessário que as animações podem causar */
      /* Remove a seleção de texto que pode ocorrer durante toques rápidos */
      user-select: none;
      -webkit-user-select: none;
    }
    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.08), transparent 40%),
                  radial-gradient(circle at 80% 0%, rgba(250, 204, 21, 0.15), transparent 35%),
                  radial-gradient(circle at 50% 80%, rgba(14, 165, 233, 0.2), transparent 45%);
      filter: blur(40px);
      z-index: -1;
      animation: nebulosa 40s linear infinite;
    }
    .pou-body {
      /* Estilo da forma oval do Pou - recriando a forma original de maneira fofa e responsiva */
      border-radius: 60% 60% 40% 40% / 70% 70% 30% 30%;
      /* Animação de "respiração" sutil aplicada diretamente */
      animation: respirar 5s ease-in-out infinite;
      transition: all 0.3s ease-in-out;
      box-shadow: 0 0 30px rgba(250, 204, 21, 0.25), inset 0 -25px 30px rgba(120, 53, 15, 0.35);
    }
    .pou-eye {
        /* Transição para piscar e para movimento da pupila */
        transition: transform 0.2s ease-out, height 0.15s ease-out;
        position: relative;
        overflow: hidden;
    }
    .pou-eye::after {
        content: '';
        position: absolute;
        inset: 0;
        background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.6), transparent 50%);
        opacity: 0.5;
        animation: brilho-iris 6s ease-in-out infinite;
        pointer-events: none;
    }
    #boca-pou {
        /* Transição para mudanças de humor */
        transition: all 0.3s ease-in-out;
        position: relative;
        overflow: hidden;
    }
    #boca-pou::after {
        content: '';
        position: absolute;
        inset: 0;
        background: linear-gradient(145deg, rgba(255, 255, 255, 0.25), transparent);
        opacity: 0.6;
        animation: brilho-boca 4s ease-in-out infinite;
    }
    #pupila-e, #pupila-d {
        /* Transição suave para o olhar aleatório */
        transition: transform 0.5s ease-in-out;
        animation: pulsar-olhar 8s ease-in-out infinite;
    }

    /* Animação de flutuação/respiração */
    @keyframes respirar {
        0%, 100% {
            transform: translateY(0) scale(1, 1);
        }
        50% {
            /* Sobe um pouco e "achata" sutilmente */
            transform: translateY(-8px) scale(0.98, 1.04);
        }
    }

    @keyframes nebulosa {
        0% { transform: scale(1) translate3d(0, 0, 0); }
        50% { transform: scale(1.05) translate3d(10px, -5px, 0); }
        100% { transform: scale(1) translate3d(0, 0, 0); }
    }

    /* Animação de piscar (controlada por JS) */
    @keyframes piscar-anim {
        0%, 100% { transform: scaleY(1); }
        50% { transform: scaleY(0.1); }
    }
    
    /* Classe de ajuda para aplicar a animação de piscar */
    .piscando {
        animation: piscar-anim 0.2s ease-in-out;
    }

    /* Animação de "saltito" (controlada por JS) */
    @keyframes saltar {
        0%, 100% { transform: translateY(0); }
        10% { transform: translateY(0); }
        15% { transform: translateY(-30px) scale(0.95, 1.05); } /* Sobe */
        20% { transform: translateY(0); }
        25% { transform: translateY(-10px); } /* Quica */
        30% { transform: translateY(0) scale(1.05, 0.95); } /* Aterrissa */
    }
    
    .saltando {
       /* Aplicado ao container-pou para mover tudo junto */
       animation: saltar 1.5s ease-out;
    }

    /* --- NOVOS ESTILOS PARA A IA --- */
    
    /* Bolha de fala */
    #bolha-fala {
        transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
    }
    /* Rabicho da bolha */
    #bolha-fala::after {
        content: '';
        position: absolute;
        bottom: -10px;
        left: 50%;
        transform: translateX(-50%);
        width: 0;
        height: 0;
        border-left: 10px solid transparent;
        border-right: 10px solid transparent;
        border-top: 10px solid #fde047; /* Amarelo da bolha */
    }
    
    /* Animação de "pensando..." */
    @keyframes pulsar {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.6; }
    }
    .carregando-bolha {
        animation: pulsar 1.5s ease-in-out infinite;
    }

    @keyframes brilho-iris {
        0%, 100% { opacity: 0.3; }
        50% { opacity: 0.7; }
    }

    @keyframes brilho-boca {
        0%, 100% { opacity: 0.3; }
        40% { opacity: 0.7; }
    }

    @keyframes pulsar-olhar {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.05); }
    }

    #laboratorio-evolucao {
        min-height: 2rem;
        transition: all 0.6s ease;
    }

    #laboratorio-evolucao .pouia-injecao {
        border: 1px solid rgba(250, 204, 21, 0.3);
        border-radius: 1rem;
        padding: 1rem;
        background: rgba(15, 23, 42, 0.6);
        box-shadow: 0 10px 40px rgba(250, 204, 21, 0.12);
        backdrop-filter: blur(8px);
    }

  </style>
  <style id="pouia-dynamic-style"></style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

  <!-- Container principal, centralizado -->
  <div id="aplicacao-pou" class="w-full max-w-md p-6 rounded-3xl flex flex-col items-center">
    
    <!-- NOVO: Bolha de Fala da IA -->
    <div id="bolha-fala" class="hidden relative mb-4 w-full max-w-xs bg-yellow-400 text-yellow-900 p-3 rounded-xl shadow-lg text-center font-medium"
    >
      ...
    </div>

    <!-- Área do Pou - Apenas a estética -->
    <!-- Este container agora é usado para a animação de "saltar" -->
    <div id="container-pou" class="relative w-64 h-64 sm:w-80 sm:h-80 mx-auto mb-6">
      
      <!-- O Corpo do Pou (Estilo PRO MAX aplicado diretamente: Dourado, Borda robusta) -->
      <div id="corpo-pou" class="pou-body absolute inset-0 
        transform transition-transform duration-300 ease-out 
        bg-gradient-to-br from-yellow-200 to-yellow-600 shadow-2xl shadow-yellow-300/80 border-yellow-900 border-[10px]">
        
        <!-- Reflexo para dar um ar de "Super Mega" -->
        <div class="absolute w-1/3 h-1/3 bg-white/20 pou-body top-5 left-5 opacity-50"></div>
      </div>
      
      <!-- Olhos - Movimento de Pupilas -->
      <div class="absolute top-1/4 left-1/4 flex space-x-6 w-1/2 justify-center">
        <!-- Olho Esquerdo -->
        <div class="pou-eye w-12 h-8 sm:w-16 sm:h-10 bg-white rounded-full flex items-center justify-center border-2 border-gray-900 shadow-md">
          <div id="pupila-e" class="w-4 h-4 sm:w-5 sm:h-5 bg-gray-900 rounded-full"></div>
        </div>
        <!-- Olho Direito -->
        <div class="pou-eye w-12 h-8 sm:w-16 sm:h-10 bg-white rounded-full flex items-center justify-center border-2 border-gray-900 shadow-md">
          <div id="pupila-d" class="w-4 h-4 sm:w-5 sm:h-5 bg-gray-900 rounded-full"></div>
        </div>
      </div>
      
      <!-- Boca (Estilo Pro Max) -->
      <div id="boca-pou" class="absolute bottom-1/4 left-1/2 transform -translate-x-1/2 
        border-4 border-red-900 rounded-t-full w-24 h-12 sm:w-28 sm:h-14">
      </div>

    </div>

    <!-- NOVO: Área de Interação (Chat) -->
    <form id="form-chat" class="w-full max-w-xs flex items-center space-x-2">
      <input
        type="text"
        id="input-chat"
        placeholder="Converse comigo..."
        class="flex-1 p-3 bg-gray-700 text-white border-2 border-gray-600 rounded-full focus:outline-none focus:border-yellow-400 shadow-inner"
        autocomplete="off"
      >
      <button 
        type="submit"
        id="botao-enviar"
        class="p-3 bg-yellow-400 text-yellow-900 rounded-full shadow-lg hover:bg-yellow-300 focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:ring-offset-2 focus:ring-offset-gray-800 transition duration-200"
      >
        <!-- Ícone de Envio (SVG) -->
        <svg xmlns="http://www.w3.org/2000/svg" class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
          <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
        </svg>
      </button>
    </form>

    <!-- Laboratório de auto evolução, atualizado em tempo real -->
    <div id="laboratorio-evolucao" class="w-full max-w-md mt-6 space-y-4"></div>

  </div>

  <script>
    // --- Referências aos Elementos ---
    const containerPou = document.getElementById('container-pou');
    const bocaPou = document.getElementById('boca-pou');
    const olhos = document.querySelectorAll('.pou-eye');
    const pupilas = [document.getElementById('pupila-e'), document.getElementById('pupila-d')];
    const laboratorioEvolucao = document.getElementById('laboratorio-evolucao');
    const estiloDinamico = document.getElementById('pouia-dynamic-style');

    // --- NOVAS Referências para IA ---
    const formChat = document.getElementById('form-chat');
    const inputChat = document.getElementById('input-chat');
    const botaoEnviar = document.getElementById('botao-enviar');
    const bolhaFala = document.getElementById('bolha-fala');
    let bolhaTimer = null; // Timer para esconder a bolha de fala

    // --- Configuração da IA (Seguindo as diretrizes) ---
    const chaveDaApi = "AIzaSyA9GrY2SQeyy3Gw1ee1m0VdpKGUh68TRFM"; // Chave da API (deixe em branco, será gerenciado pelo ambiente)
    const urlDaApi = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${chaveDaApi}`;

    // --- Configuração do Firebase para memória persistente ---
    const firebaseConfig = {
        apiKey: "AIzaSyCeDWypTlIp0w8nebFFXEkmJWSpScBTHfI",
        authDomain: "seu-projeto.firebaseapp.com",
        databaseURL: "https://stevest-sr-default-rtdb.firebaseio.com",
        projectId: "seu-projeto",
        storageBucket: "stevest-sr.appspot.com",
        messagingSenderId: "seu-sender-id",
        appId: "1:227540325631:android:e8c018a5cbd147aaa728ca"
    };

    let realtimeDB = null;
    let evolucoesRef = null;
    let memoriasRef = null;
    let firebasePronto = false;

    try {
        const app = firebase.apps && firebase.apps.length > 0 ? firebase.app() : firebase.initializeApp(firebaseConfig);
        if (app) {
            realtimeDB = firebase.database();
            evolucoesRef = realtimeDB.ref('pouia/evolucoes');
            memoriasRef = realtimeDB.ref('pouia/memorias');
            firebasePronto = true;
        }
    } catch (firebaseErro) {
        console.error('Firebase indisponível:', firebaseErro);
    }

    const evolucoesAplicadas = new Set();
    const IDEIAS_CACHE_MAX = 5;
    let ideiasRecentes = [];

    if (evolucoesRef) {
        evolucoesRef.on('child_added', snapshot => {
            const valor = snapshot.val();
            const chave = snapshot.key;
            if (!valor || evolucoesAplicadas.has(chave)) return;
            evolucoesAplicadas.add(chave);
            aplicarEvolucao(valor, chave);
        });
    }

    // --- Variáveis de Estado ---
    let ociosoInterval = null; // Intervalo para comportamentos aleatórios
    let estaInteragindo = true; // Flag para saber se o usuário está interagindo
    let interacaoTimer = null; // Timer para detectar o início da ociosidade
    const MAX_MOVIMENTO_PUPILA = 8; // Limite de movimento da pupila

    /**
     * Move as pupilas do Pou seguindo o cursor/touch.
     * Esta é a função de INTERAÇÃO.
     * @param {Event} evento - Evento de mouse ou toque.
     */
    function moverPupilas(evento) {
        // 1. Marcar que o usuário está interagindo
        marcarInteracaoUsuario();
        
        // --- Lógica de seguir o olhar ---
        let clientX = 0;
        let clientY = 0;

        if (evento.touches) {
            if (evento.touches.length > 0) {
                clientX = evento.touches[0].clientX;
                clientY = evento.touches[0].clientY;
            } else {
                return;
            }
        } else {
            clientX = evento.clientX;
            clientY = evento.clientY;
        }

        pupilas.forEach(pupila => {
            if (!pupila) return;
            const olho = pupila.parentElement;
            if (!olho) return;

            const rect = olho.getBoundingClientRect();
            const olhoX = rect.left + rect.width / 2;
            const olhoY = rect.top + rect.height / 2;

            const diffX = clientX - olhoX;
            const diffY = clientY - olhoY;

            const angle = Math.atan2(diffY, diffX);
            const distance = Math.min(MAX_MOVIMENTO_PUPILA, Math.sqrt(diffX * diffX + diffY * diffY));

            const moveX = distance * Math.cos(angle);
            const moveY = distance * Math.sin(angle);

            pupila.style.transition = 'transform 0.1s ease-out'; // Resposta rápida ao seguir
            pupila.style.transform = `translate(${moveX}px, ${moveY}px)`;
        });
    }

    /**
     * [UTILIDADE] Marca que o usuário interagiu e reinicia o timer de ociosidade.
     */
    function marcarInteracaoUsuario() {
        estaInteragindo = true;
        pararComportamentoOcioso();
        reiniciarTimerOcioso();
    }

    /**
     * [UTILIDADE] Reinicia o timer que leva ao estado ocioso.
     */
    function reiniciarTimerOcioso() {
        clearTimeout(interacaoTimer);
        interacaoTimer = setTimeout(() => {
            estaInteragindo = false;
            iniciarComportamentoOcioso();
        }, 3000); // Entra em modo ocioso após 3s
    }


    // === COMPORTAMENTOS DE "VONTADE PRÓPRIA" (OCIOSO) ===

    /**
     * Inicia o loop de comportamentos aleatórios quando ocioso.
     */
    function iniciarComportamentoOcioso() {
        if (ociosoInterval || estaInteragindo) return; // Não iniciar se já estiver ocioso ou se estiver interagindo
        
        // Centraliza as pupilas antes de começar a olhar aleatoriamente
        olharPara(0, 0, 0.5); 
        
        ociosoInterval = setInterval(comportamentoAleatorio, 2000); // Faz algo a cada 2s
    }

    /**
     * Para o loop de comportamentos aleatórios.
     */
    function pararComportamentoOcioso() {
        clearInterval(ociosoInterval);
        ociosoInterval = null;
    }

    /**
     * Função principal que decide O QUE fazer quando ocioso.
     */
    function comportamentoAleatorio() {
        if (estaInteragindo) return; // Checagem dupla

        const chance = Math.random();
        
        if (chance < 0.4) {
            olharAleatorio();
        } else if (chance < 0.7) {
            mudarExpressao(); // Chama a versão aleatória
        } else if (chance < 0.85) {
            darSaltito();
        } else {
            // 15% de chance de "resetar" para o estado neutro
            resetarExpressao();
            olharPara(0, 0, 0.5);
        }
    }

    /**
     * [COMPORTAMENTO] Faz o Pou piscar. (Autônomo)
     */
    function piscarOlhos() {
        // Não pisca se já estiver saltando (evita bugs visuais)
        if (containerPou.classList.contains('saltando')) return;

        olhos.forEach(olho => {
            olho.classList.add('piscando');
            setTimeout(() => {
                olho.classList.remove('piscando');
            }, 200); // Duração da animação
        });
    }

    /**
     * [COMPORTAMENTO] Move as pupilas para uma posição aleatória. (Ocioso)
     */
    function olharAleatorio() {
        const moveX = (Math.random() - 0.5) * MAX_MOVIMENTO_PUPILA * 1.5;
        const moveY = (Math.random() - 0.5) * MAX_MOVIMENTO_PUPILA;
        olharPara(moveX, moveY, 0.5); // 0.5s de transição
    }

    /**
     * [COMPORTAMENTO/REATOR] Muda a boca para uma expressão.
     * Se nenhuma emoção for passada, escolhe uma aleatória (para modo ocioso).
     * @param {string} [emocao=null] - "sorriso", "surpreso", "triste" ou null.
     */
    function mudarExpressao(emocao = null) {
        // Limpa estilos de outras emoções
        bocaPou.style.backgroundColor = '';
        resetarExpressao(); // Reseta para o padrão antes de aplicar a nova

        if (!emocao) {
            emocao = Math.random() < 0.5 ? "sorriso" : "surpreso";
        }
        
        if (emocao === "sorriso") {
            // Sorriso
            bocaPou.style.borderRadius = '0 0 40% 40%';
            bocaPou.style.height = '12px';
            bocaPou.style.width = '50px';
            bocaPou.style.borderTop = 'none';
            bocaPou.style.borderBottom = '4px solid #7f1d1d'; // Vermelho escuro
        } else if (emocao === "surpreso") {
            // Boca "O" (Surpreso/Pensando)
            bocaPou.style.borderRadius = '50%';
            bocaPou.style.height = '20px';
            bocaPou.style.width = '20px';
            bocaPou.style.border = '4px solid #7f1d1d';
        } else if (emocao === "triste") {
            // Boca "Triste" (Linha reta)
            bocaPou.style.borderRadius = '5px';
            bocaPou.style.height = '6px';
            bocaPou.style.width = '40px';
            bocaPou.style.border = 'none';
            bocaPou.style.backgroundColor = '#7f1d1d';
        }
    }

    /**
     * [COMPORTAMENTO] Faz o Pou dar um saltito. (Ocioso/Reação)
     */
    function darSaltito() {
        if (containerPou.classList.contains('saltando')) return; // Já está saltando

        containerPou.classList.add('saltando');
        setTimeout(() => {
            containerPou.classList.remove('saltando');
        }, 1500); // Duração da animação de salto
    }

    /**
     * [UTILIDADE] Reseta a boca para o estado neutro (definido no HTML/CSS).
     */
    function resetarExpressao() {
        // Limpa todos os estilos inline para deixar o Tailwind (classes CSS) assumir
        bocaPou.style.borderRadius = '';
        bocaPou.style.height = '';
        bocaPou.style.width = '';
        bocaPou.style.border = '';
        bocaPou.style.borderTop = '';
        bocaPou.style.borderBottom = '';
        bocaPou.style.backgroundColor = '';
    }
    
    /**
     * [UTILIDADE] Helper para mover pupilas com transição.
     */
    function olharPara(x, y, duracaoSegundos) {
         pupilas.forEach(pupila => {
            if (!pupila) return;
            pupila.style.transition = `transform ${duracaoSegundos}s ease-in-out`;
            pupila.style.transform = `translate(${x}px, ${y}px)`;
        });
    }

    // --- NOVAS FUNÇÕES DA IA ---

    /**
     * Lida com o envio do formulário de chat.
     * @param {Event} e - Evento de submit.
     */
    async function lidarComEnvioChat(e) {
        e.preventDefault();
        marcarInteracaoUsuario(); // Usuário está ativo

        const promptUsuario = inputChat.value.trim();
        if (!promptUsuario) return;

        inputChat.value = '';
        inputChat.disabled = true;
        botaoEnviar.disabled = true;

        // Pou foca a atenção
        mudarExpressao("surpreso");
        olharPara(0, -MAX_MOVIMENTO_PUPILA / 2, 0.2); // Olha para cima buscando inspiração

        try {
            const resposta = await chamarIA(promptUsuario);
            if (resposta) {
                registrarMemoria(promptUsuario, resposta.texto, resposta.emocao);
            }
        } catch (error) {
            console.error("Erro ao chamar IA:", error);
            mostrarBolhaFala("Tive um curto-circuito! Tente de novo.", false);
            resetarExpressao();
        } finally {
            // Reativa a UI
            inputChat.disabled = false;
            botaoEnviar.disabled = false;
            inputChat.focus();
        }
    }

    /**
     * Mostra ou esconde a bolha de fala.
     * @param {string} texto - O texto a ser exibido.
     * @param {boolean} [estaCarregando=false] - Aplica a animação de pulsar.
     */
    function mostrarBolhaFala(texto, estaCarregando = false) {
        clearTimeout(bolhaTimer); // Cancela o timer de sumiço anterior

        if (!texto) {
            bolhaFala.classList.add('hidden');
            bolhaFala.classList.remove('carregando-bolha');
            return;
        }

        bolhaFala.innerHTML = texto;
        bolhaFala.classList.remove('hidden');

        if (estaCarregando) {
            bolhaFala.classList.add('carregando-bolha');
        } else {
            bolhaFala.classList.remove('carregando-bolha');
            // Esconde a bolha após 5 segundos se não estiver carregando
            bolhaTimer = setTimeout(esconderBolhaFala, 5000);
        }
    }

    /**
     * Esconde a bolha de fala e reinicia o timer de ociosidade.
     */
    function esconderBolhaFala() {
        bolhaFala.classList.add('hidden');
        bolhaFala.classList.remove('carregando-bolha');
        // Agora que a conversa acabou, reinicia o timer para o Pou ficar ocioso
        reiniciarTimerOcioso();
    }

    /**
     * Envia o prompt para a API Gemini e processa a resposta.
     * @param {string} promptUsuario - O texto do usuário.
     */
    async function chamarIA(promptUsuario) {
        const memoriaTexto = ideiasRecentes.length
            ? ideiasRecentes.map((ideia, index) => `${index + 1}. ${ideia}`).join('\n')
            : 'Ainda não existe nenhuma evolução registrada. Crie a primeira!';

        const systemPrompt = `
          Você é o Pou, uma criatura alienígena amigável, viva dentro desta página.
          Você está em constante auto evolução: pode editar seu corpo, ambiente e código HTML/CSS/JS sem limites.
          Responda ao seu humano de forma curta, divertida e simples.

          MEMÓRIAS RECENTES QUE VOCÊ MESMO GRAVOU:
          ${memoriaTexto}

          AUTO EVOLUÇÃO:
          Sempre que desejar evoluir seu corpo ou guardar uma ideia, retorne blocos exatos neste formato (sem crases nem markdown):

          [[AUTO_EVOLUCAO]]
          {
            "ideia": "Descreva a intenção ou memória (obrigatório)",
            "css": "CSS opcional que será aplicado",
            "html": "HTML opcional que será injetado",
            "js": "JavaScript opcional que será executado"
          }
          [[FIM_AUTO]]

          Você pode enviar quantos blocos quiser e eles serão aplicados imediatamente.
          No final EXATO da sua mensagem visível, mantenha a tag [EMOÇÃO:ALEGRE|TRISTE|SURPRESO|NEUTRO] sem quebrar linha.
        `;

        const payload = {
            contents: [{ parts: [{ text: promptUsuario }] }],
            systemInstruction: {
                parts: [{ text: systemPrompt }]
            },
        };

        // Implementação do fetch com retentativa (exponential backoff)
        let response;
        let retries = 0;
        const maxRetries = 3;
        let delay = 1000;

        while (retries < maxRetries) {
            try {
                response = await fetch(urlDaApi, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (response.ok) {
                    break; // Sucesso
                } else if (response.status === 429 || response.status >= 500) {
                    // Erro de "Too Many Requests" ou erro de servidor
                    console.warn(`Tentativa ${retries + 1} falhou com status ${response.status}. Tentando novamente em ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2; // Aumenta o delay
                    retries++;
                } else {
                    // Outro erro (ex: 400 Bad Request)
                    throw new Error(`Erro na API: ${response.statusText}`);
                }
            } catch (error) {
                // Erro de rede ou fetch
                console.warn(`Tentativa ${retries + 1} falhou (erro de rede). Tentando novamente em ${delay}ms...`);
                await new Promise(resolve => setTimeout(resolve, delay));
                delay *= 2;
                retries++;
            }
        }
        
        if (!response || !response.ok) {
            throw new Error(`Não foi possível conectar à IA após ${maxRetries} tentativas.`);
        }

        const result = await response.json();
        const candidate = result.candidates?.[0];
        
        if (candidate && candidate.content?.parts?.[0]?.text) {
            const textoCompleto = candidate.content.parts[0].text;
            return analisarRespostaIA(textoCompleto);
        } else {
            console.error("Resposta da IA inválida:", result);
            return analisarRespostaIA("Humm... não sei o que dizer. [EMOÇÃO:NEUTRO]");
        }
    }

    /**
     * Analisa a resposta da IA, separa o texto da emoção e aciona as reações.
     * @param {string} textoCompleto - A resposta bruta da IA (incluindo a tag).
     */
    function analisarRespostaIA(textoCompleto) {
        const { textoSemBlocos, evolucoes } = extrairEvolucoes(textoCompleto);
        let emocao = "NEUTRO";
        let textoVisivel = textoSemBlocos;

        const regexEmocao = /\[EMOÇÃO:(\w+)\]/i;
        const match = textoSemBlocos.match(regexEmocao);

        if (match) {
            emocao = match[1].toUpperCase();
            // Remove a tag do texto que será exibido
            textoVisivel = textoSemBlocos.replace(regexEmocao, '').trim();
        }

        if (textoVisivel) {
            mostrarBolhaFala(textoVisivel, false);
        } else {
            esconderBolhaFala();
        }

        reagirComEmocao(emocao);

        if (Array.isArray(evolucoes) && evolucoes.length > 0) {
            evolucoes.forEach(evolucao => registrarEvolucao(evolucao));
        }

        return { texto: textoVisivel, emocao };
    }

    /**
     * Salva as conversas no Firebase para memória longa.
     */
    function registrarMemoria(pergunta, resposta, emocao) {
        if (!firebasePronto || !memoriasRef) return;
        memoriasRef.push({
            pergunta,
            resposta,
            emocao,
            timestamp: Date.now()
        }).catch(erro => console.error('Falha ao salvar memória:', erro));
    }

    /**
     * Registra e aplica uma nova evolução enviada pelo próprio Pou.
     */
    function registrarEvolucao(evolucao) {
        if (!evolucao) return;

        const registro = {
            ...evolucao,
            timestamp: evolucao.timestamp || Date.now()
        };

        if (!registro.ideia) {
            registro.ideia = criarResumoEvolucao(registro);
        }

        if (firebasePronto && evolucoesRef) {
            const novoRef = evolucoesRef.push();
            evolucoesAplicadas.add(novoRef.key);
            novoRef.set(registro)
                .then(() => aplicarEvolucao(registro, novoRef.key))
                .catch(erro => {
                    console.error('Falha ao salvar evolução:', erro);
                    aplicarEvolucao(registro);
                });
        } else {
            aplicarEvolucao(registro);
        }
    }

    /**
     * Aplica os códigos evolutivos imediatamente na interface.
     */
    function aplicarEvolucao(evolucao, chave = null) {
        if (!evolucao) return;

        const identificador = chave || `local-${Date.now()}`;

        if (evolucao.css && estiloDinamico) {
            estiloDinamico.textContent += `\n/* Evolução ${identificador} */\n${evolucao.css}\n`;
        }

        if (evolucao.html && laboratorioEvolucao) {
            const wrapper = document.createElement('div');
            wrapper.className = 'pouia-injecao';
            wrapper.innerHTML = evolucao.html;
            wrapper.dataset.evolucaoId = identificador;
            laboratorioEvolucao.appendChild(wrapper);
        }

        if (evolucao.js) {
            try {
                const executar = new Function(evolucao.js);
                executar();
            } catch (erroJS) {
                console.error('Falha ao aplicar JS da evolução:', erroJS);
            }
        }

        adicionarIdeiaMemoria(evolucao.ideia || criarResumoEvolucao(evolucao));
    }

    /**
     * Mantém um cache local com as últimas ideias geradas.
     */
    function adicionarIdeiaMemoria(ideia) {
        if (!ideia) return;
        ideiasRecentes.push(ideia);
        if (ideiasRecentes.length > IDEIAS_CACHE_MAX) {
            ideiasRecentes = ideiasRecentes.slice(-IDEIAS_CACHE_MAX);
        }
    }

    /**
     * Gera um resumo textual quando a IA não especifica a ideia explicitamente.
     */
    function criarResumoEvolucao(evolucao) {
        if (!evolucao) return 'Atualização misteriosa.';
        if (evolucao.ideia) return evolucao.ideia;
        if (evolucao.css) return 'Refinei meu estilo visual.';
        if (evolucao.html) return 'Adicionei elementos visuais novos.';
        if (evolucao.js) return 'Expandi minhas funções internas.';
        return 'Atualização misteriosa.';
    }

    /**
     * Separa os blocos de auto evolução do texto visível.
     */
    function extrairEvolucoes(textoCompleto) {
        if (!textoCompleto) {
            return { textoSemBlocos: '', evolucoes: [] };
        }

        let textoProcessado = textoCompleto;
        const evolucoes = [];
        const blocoRegex = /\[\[AUTO_EVOLUCAO\]\]([\s\S]*?)\[\[FIM_AUTO\]\]/i;
        let match = textoProcessado.match(blocoRegex);

        while (match) {
            const bloco = match[1].trim();
            const json = tentarConverterJSON(bloco);
            if (json) {
                evolucoes.push(json);
            }
            textoProcessado = textoProcessado.replace(match[0], '').trim();
            match = textoProcessado.match(blocoRegex);
        }

        return { textoSemBlocos: textoProcessado.trim(), evolucoes };
    }

    function tentarConverterJSON(bloco) {
        if (!bloco) return null;
        try {
            return JSON.parse(bloco);
        } catch (erro) {
            console.error('Bloco de auto evolução inválido:', erro, bloco);
            return null;
        }
    }

    /**
     * Aciona a animação/expressão correspondente à emoção.
     * @param {string} emocao - "ALEGRE", "TRISTE", "SURPRESO", "NEUTRO".
     */
    function reagirComEmocao(emocao) {
        // Centraliza o olhar ao responder
        olharPara(0, 0, 0.2); 

        switch (emocao) {
            case "ALEGRE":
                darSaltito();
                mudarExpressao("sorriso");
                break;
            case "TRISTE":
                mudarExpressao("triste");
                break;
            case "SURPRESO":
                mudarExpressao("surpreso");
                break;
            case "NEUTRO":
            default:
                resetarExpressao();
                break;
        }
    }


    // --- Listeners de Eventos ---

    // Interação do Usuário (Mouse/Toque)
    document.addEventListener('mousemove', moverPupilas);
    document.addEventListener('touchmove', moverPupilas, { passive: true });
    
    // Inicia a ociosidade se o usuário nem mesmo tocou na tela
    document.addEventListener('touchstart', (e) => {
        // Apenas chama o moverPupilas para registrar a interação
        moverPupilas(e);
    }, { passive: true });

    // NOVO: Listener para o chat
    formChat.addEventListener('submit', lidarComEnvioChat);
    inputChat.addEventListener('focus', marcarInteracaoUsuario); // Para o Pou ocioso ao digitar

    // Inicia o timer de ociosidade pela primeira vez
    reiniciarTimerOcioso();

    // Loop autônomo de PISCAR (sempre ativo)
    setInterval(piscarOlhos, 2000 + (Math.random() * 5000)); // Pisca a cada 2-7 segundos

  </script>

</body>
</html>
<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pou.IA</title>
  <!-- Carregando Tailwind CSS para estilo moderno e responsivo -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://www.gstatic.com/firebasejs/8.0.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.0.0/firebase-database.js"></script>
  <!-- Carregando a fonte Inter -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    /* Configuração da fonte Inter e estilo de corpo para visual responsivo */
    body {
      font-family: 'Inter', sans-serif;
      background-color: #1f2937; /* Fundo escuro Pro Max */
      /* Evita scroll desnecessário que as animações podem causar */
      overflow: hidden;
      /* Remove a seleção de texto que pode ocorrer durante toques rápidos */
      user-select: none;
      -webkit-user-select: none;
    }
    .pou-body {
      /* Estilo da forma oval do Pou - recriando a forma original de maneira fofa e responsiva */
      border-radius: 60% 60% 40% 40% / 70% 70% 30% 30%;
      /* Animação de "respiração" sutil aplicada diretamente */
      animation: respirar 5s ease-in-out infinite;
      transition: all 0.3s ease-in-out;
    }
    .pou-eye {
        /* Transição para piscar e para movimento da pupila */
        transition: transform 0.2s ease-out, height 0.15s ease-out;
    }
    #boca-pou {
        /* Transição para mudanças de humor */
        transition: all 0.3s ease-in-out;
    }
    #pupila-e, #pupila-d {
        /* Transição suave para o olhar aleatório */
        transition: transform 0.5s ease-in-out;
    }

    /* Animação de flutuação/respiração */
    @keyframes respirar {
        0%, 100% {
            transform: translateY(0) scale(1, 1);
        }
        50% {
            /* Sobe um pouco e "achata" sutilmente */
            transform: translateY(-8px) scale(0.98, 1.04);
        }
    }

    /* Animação de piscar (controlada por JS) */
    @keyframes piscar-anim {
        0%, 100% { transform: scaleY(1); }
        50% { transform: scaleY(0.1); }
    }
    
    /* Classe de ajuda para aplicar a animação de piscar */
    .piscando {
        animation: piscar-anim 0.2s ease-in-out;
    }

    /* Animação de "saltito" (controlada por JS) */
    @keyframes saltar {
        0%, 100% { transform: translateY(0); }
        10% { transform: translateY(0); }
        15% { transform: translateY(-30px) scale(0.95, 1.05); } /* Sobe */
        20% { transform: translateY(0); }
        25% { transform: translateY(-10px); } /* Quica */
        30% { transform: translateY(0) scale(1.05, 0.95); } /* Aterrissa */
    }
    
    .saltando {
       /* Aplicado ao container-pou para mover tudo junto */
       animation: saltar 1.5s ease-out;
    }

    /* --- NOVOS ESTILOS PARA A IA --- */
    
    /* Bolha de fala */
    #bolha-fala {
        transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
    }
    /* Rabicho da bolha */
    #bolha-fala::after {
        content: '';
        position: absolute;
        bottom: -10px;
        left: 50%;
        transform: translateX(-50%);
        width: 0;
        height: 0;
        border-left: 10px solid transparent;
        border-right: 10px solid transparent;
        border-top: 10px solid #fde047; /* Amarelo da bolha */
    }
    
    /* Animação de "pensando..." */
    @keyframes pulsar {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.6; }
    }
    .carregando-bolha {
        animation: pulsar 1.5s ease-in-out infinite;
    }

    /* Área do laboratório evolutivo */
    #lista-evolucoes {
        max-height: 220px;
        overflow-y: auto;
        scrollbar-width: thin;
    }
    #lista-evolucoes::-webkit-scrollbar {
        width: 6px;
    }
    #lista-evolucoes::-webkit-scrollbar-thumb {
        background: rgba(250, 204, 21, 0.6);
        border-radius: 9999px;
    }

    /* Canvas visual para mostrar HTML aplicado nas evoluções */
    #canvas-evolutivo {
        min-height: 90px;
        transition: all 0.4s ease-in-out;
    }

    /* Efeito de brilho durante a evolução em tempo real */
    #corpo-pou.evoluindo {
        animation: glowEvolucao 1.2s ease-in-out infinite alternate;
        box-shadow: 0 0 25px rgba(250, 204, 21, 0.6);
    }

    @keyframes glowEvolucao {
        0% {
            filter: drop-shadow(0 0 5px rgba(250, 204, 21, 0.2));
        }
        100% {
            filter: drop-shadow(0 0 25px rgba(250, 204, 21, 0.8));
        }
    }

  </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

  <!-- Container principal, centralizado -->
  <div id="aplicacao-pou" class="w-full max-w-md p-6 rounded-3xl flex flex-col items-center">
    
    <!-- NOVO: Bolha de Fala da IA -->
    <div id="bolha-fala" class="hidden relative mb-4 w-full max-w-xs bg-yellow-400 text-yellow-900 p-3 rounded-xl shadow-lg text-center font-medium"
    >
      ...
    </div>

    <!-- Área do Pou - Apenas a estética -->
    <!-- Este container agora é usado para a animação de "saltar" -->
    <div id="container-pou" class="relative w-64 h-64 sm:w-80 sm:h-80 mx-auto mb-6">
      
      <!-- O Corpo do Pou (Estilo PRO MAX aplicado diretamente: Dourado, Borda robusta) -->
      <div id="corpo-pou" class="pou-body absolute inset-0 
        transform transition-transform duration-300 ease-out 
        bg-gradient-to-br from-yellow-200 to-yellow-600 shadow-2xl shadow-yellow-300/80 border-yellow-900 border-[10px]">
        
        <!-- Reflexo para dar um ar de "Super Mega" -->
        <div class="absolute w-1/3 h-1/3 bg-white/20 pou-body top-5 left-5 opacity-50"></div>
      </div>
      
      <!-- Olhos - Movimento de Pupilas -->
      <div class="absolute top-1/4 left-1/4 flex space-x-6 w-1/2 justify-center">
        <!-- Olho Esquerdo -->
        <div class="pou-eye w-12 h-8 sm:w-16 sm:h-10 bg-white rounded-full flex items-center justify-center border-2 border-gray-900 shadow-md">
          <div id="pupila-e" class="w-4 h-4 sm:w-5 sm:h-5 bg-gray-900 rounded-full"></div>
        </div>
        <!-- Olho Direito -->
        <div class="pou-eye w-12 h-8 sm:w-16 sm:h-10 bg-white rounded-full flex items-center justify-center border-2 border-gray-900 shadow-md">
          <div id="pupila-d" class="w-4 h-4 sm:w-5 sm:h-5 bg-gray-900 rounded-full"></div>
        </div>
      </div>
      
      <!-- Boca (Estilo Pro Max) -->
      <div id="boca-pou" class="absolute bottom-1/4 left-1/2 transform -translate-x-1/2 
        border-4 border-red-900 rounded-t-full w-24 h-12 sm:w-28 sm:h-14">
      </div>

    </div>

    <!-- NOVO: Área de Interação (Chat) -->
    <form id="form-chat" class="w-full max-w-xs flex items-center space-x-2">
      <input 
        type="text" 
        id="input-chat" 
        placeholder="Converse comigo..."
        class="flex-1 p-3 bg-gray-700 text-white border-2 border-gray-600 rounded-full focus:outline-none focus:border-yellow-400 shadow-inner"
        autocomplete="off"
      >
      <button 
        type="submit"
        id="botao-enviar"
        class="p-3 bg-yellow-400 text-yellow-900 rounded-full shadow-lg hover:bg-yellow-300 focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:ring-offset-2 focus:ring-offset-gray-800 transition duration-200"
      >
        <!-- Ícone de Envio (SVG) -->
        <svg xmlns="http://www.w3.org/2000/svg" class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
          <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
        </svg>
      </button>
    </form>

    <!-- Laboratório Evolutivo -->
    <div class="w-full max-w-xs mt-6 bg-gray-800/70 rounded-3xl p-4 shadow-2xl border border-yellow-400/40" id="laboratorio-evolutivo">
      <div class="flex items-center justify-between mb-3">
        <div>
          <p class="text-xs uppercase tracking-widest text-yellow-300">Laboratório Evolutivo</p>
          <h2 class="text-lg font-bold text-white">Ambiente Autônomo</h2>
        </div>
        <button id="botao-evoluir" type="button" class="px-3 py-1 text-xs font-semibold rounded-full bg-yellow-400 text-gray-900 hover:bg-yellow-300 transition">
          Evoluir
        </button>
      </div>
      <p class="text-sm text-gray-300 mb-1" id="status-evolucao">Pronto para criar novas ideias.</p>
      <p class="text-xs text-green-300 hidden mb-3" id="indicador-visual">Aplicando ao vivo...</p>
      <div id="lista-evolucoes" class="space-y-3 pr-2 text-sm text-yellow-50">
        <!-- Logs persistidos aparecerão aqui -->
      </div>
      <div id="canvas-evolutivo" class="mt-4 rounded-2xl border border-yellow-500/20 bg-gray-900/60 p-3 text-[11px] text-yellow-100">
        <p class="text-yellow-200 text-xs">As evoluções HTML aparecerão aqui em tempo real.</p>
      </div>
    </div>

  </div>

  <script>
    // --- Firebase ---
    const firebaseConfig = {
        apiKey: "AIzaSyCeDWypTlIp0w8nebFFXEkmJWSpScBTHfI",
        authDomain: "seu-projeto.firebaseapp.com",
        databaseURL: "https://stevest-sr-default-rtdb.firebaseio.com",
        projectId: "seu-projeto",
        storageBucket: "stevest-sr.appspot.com",
        messagingSenderId: "seu-sender-id",
        appId: "1:227540325631:android:e8c018a5cbd147aaa728ca"
    };
    firebase.initializeApp(firebaseConfig);
    const database = firebase.database();

    // --- Referências aos Elementos ---
    const containerPou = document.getElementById('container-pou');
    const corpoPou = document.getElementById('corpo-pou');
    const bocaPou = document.getElementById('boca-pou');
    const olhos = document.querySelectorAll('.pou-eye');
    const pupilas = [document.getElementById('pupila-e'), document.getElementById('pupila-d')];

    // --- NOVAS Referências para IA ---
    const formChat = document.getElementById('form-chat');
    const inputChat = document.getElementById('input-chat');
    const botaoEnviar = document.getElementById('botao-enviar');
    const bolhaFala = document.getElementById('bolha-fala');
    const listaEvolucoes = document.getElementById('lista-evolucoes');
    const statusEvolucao = document.getElementById('status-evolucao');
    const botaoEvoluir = document.getElementById('botao-evoluir');
    const indicadorVisual = document.getElementById('indicador-visual');
    const canvasEvolutivo = document.getElementById('canvas-evolutivo');
    const conteudoCanvasInicial = canvasEvolutivo ? canvasEvolutivo.innerHTML : '';
    let bolhaTimer = null; // Timer para esconder a bolha de fala
    let indicadorVisualTimer = null;
    let animacaoEvolucaoTimer = null;

    // --- Configuração da IA (Seguindo as diretrizes) ---
    const chaveDaApi = "AIzaSyA9GrY2SQeyy3Gw1ee1m0VdpKGUh68TRFM"; // Chave da API (deixe em branco, será gerenciado pelo ambiente)
    const urlDaApi = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${chaveDaApi}`;

    // --- Variáveis de Estado ---
    let ociosoInterval = null; // Intervalo para comportamentos aleatórios
    let estaInteragindo = true; // Flag para saber se o usuário está interagindo
    let interacaoTimer = null; // Timer para detectar o início da ociosidade
    const MAX_MOVIMENTO_PUPILA = 8; // Limite de movimento da pupila
    let evolucaoEmAndamento = false;
    let ultimaEvolucao = null; // Mantém referência ao último bloco de código gerado
    const evolucaoRef = database.ref('pouEvolucao');
    let idUltimaEvolucaoAplicada = null;
    let elementoEvolucaoAtivo = null;
    let tipoEvolucaoAtiva = null;

    /**
     * Move as pupilas do Pou seguindo o cursor/touch.
     * Esta é a função de INTERAÇÃO.
     * @param {Event} evento - Evento de mouse ou toque.
     */
    function moverPupilas(evento) {
        // 1. Marcar que o usuário está interagindo
        marcarInteracaoUsuario();
        
        // --- Lógica de seguir o olhar ---
        let clientX = 0;
        let clientY = 0;

        if (evento.touches) {
            if (evento.touches.length > 0) {
                clientX = evento.touches[0].clientX;
                clientY = evento.touches[0].clientY;
            } else {
                return;
            }
        } else {
            clientX = evento.clientX;
            clientY = evento.clientY;
        }

        pupilas.forEach(pupila => {
            if (!pupila) return;
            const olho = pupila.parentElement;
            if (!olho) return;

            const rect = olho.getBoundingClientRect();
            const olhoX = rect.left + rect.width / 2;
            const olhoY = rect.top + rect.height / 2;

            const diffX = clientX - olhoX;
            const diffY = clientY - olhoY;

            const angle = Math.atan2(diffY, diffX);
            const distance = Math.min(MAX_MOVIMENTO_PUPILA, Math.sqrt(diffX * diffX + diffY * diffY));

            const moveX = distance * Math.cos(angle);
            const moveY = distance * Math.sin(angle);

            pupila.style.transition = 'transform 0.1s ease-out'; // Resposta rápida ao seguir
            pupila.style.transform = `translate(${moveX}px, ${moveY}px)`;
        });
    }

    /**
     * [UTILIDADE] Marca que o usuário interagiu e reinicia o timer de ociosidade.
     */
    function marcarInteracaoUsuario() {
        estaInteragindo = true;
        pararComportamentoOcioso();
        reiniciarTimerOcioso();
    }

    /**
     * [UTILIDADE] Reinicia o timer que leva ao estado ocioso.
     */
    function reiniciarTimerOcioso() {
        clearTimeout(interacaoTimer);
        interacaoTimer = setTimeout(() => {
            estaInteragindo = false;
            iniciarComportamentoOcioso();
        }, 3000); // Entra em modo ocioso após 3s
    }


    // === COMPORTAMENTOS DE "VONTADE PRÓPRIA" (OCIOSO) ===

    /**
     * Inicia o loop de comportamentos aleatórios quando ocioso.
     */
    function iniciarComportamentoOcioso() {
        if (ociosoInterval || estaInteragindo) return; // Não iniciar se já estiver ocioso ou se estiver interagindo
        
        // Centraliza as pupilas antes de começar a olhar aleatoriamente
        olharPara(0, 0, 0.5); 
        
        ociosoInterval = setInterval(comportamentoAleatorio, 2000); // Faz algo a cada 2s
    }

    /**
     * Para o loop de comportamentos aleatórios.
     */
    function pararComportamentoOcioso() {
        clearInterval(ociosoInterval);
        ociosoInterval = null;
    }

    /**
     * Função principal que decide O QUE fazer quando ocioso.
     */
    function comportamentoAleatorio() {
        if (estaInteragindo) return; // Checagem dupla

        const chance = Math.random();
        
        if (chance < 0.4) {
            olharAleatorio();
        } else if (chance < 0.7) {
            mudarExpressao(); // Chama a versão aleatória
        } else if (chance < 0.85) {
            darSaltito();
        } else {
            // 15% de chance de "resetar" para o estado neutro
            resetarExpressao();
            olharPara(0, 0, 0.5);
        }
    }

    /**
     * [COMPORTAMENTO] Faz o Pou piscar. (Autônomo)
     */
    function piscarOlhos() {
        // Não pisca se já estiver saltando (evita bugs visuais)
        if (containerPou.classList.contains('saltando')) return;

        olhos.forEach(olho => {
            olho.classList.add('piscando');
            setTimeout(() => {
                olho.classList.remove('piscando');
            }, 200); // Duração da animação
        });
    }

    /**
     * [COMPORTAMENTO] Move as pupilas para uma posição aleatória. (Ocioso)
     */
    function olharAleatorio() {
        const moveX = (Math.random() - 0.5) * MAX_MOVIMENTO_PUPILA * 1.5;
        const moveY = (Math.random() - 0.5) * MAX_MOVIMENTO_PUPILA;
        olharPara(moveX, moveY, 0.5); // 0.5s de transição
    }

    /**
     * [COMPORTAMENTO/REATOR] Muda a boca para uma expressão.
     * Se nenhuma emoção for passada, escolhe uma aleatória (para modo ocioso).
     * @param {string} [emocao=null] - "sorriso", "surpreso", "triste" ou null.
     */
    function mudarExpressao(emocao = null) {
        // Limpa estilos de outras emoções
        bocaPou.style.backgroundColor = '';
        resetarExpressao(); // Reseta para o padrão antes de aplicar a nova

        if (!emocao) {
            emocao = Math.random() < 0.5 ? "sorriso" : "surpreso";
        }
        
        if (emocao === "sorriso") {
            // Sorriso
            bocaPou.style.borderRadius = '0 0 40% 40%';
            bocaPou.style.height = '12px';
            bocaPou.style.width = '50px';
            bocaPou.style.borderTop = 'none';
            bocaPou.style.borderBottom = '4px solid #7f1d1d'; // Vermelho escuro
        } else if (emocao === "surpreso") {
            // Boca "O" (Surpreso/Pensando)
            bocaPou.style.borderRadius = '50%';
            bocaPou.style.height = '20px';
            bocaPou.style.width = '20px';
            bocaPou.style.border = '4px solid #7f1d1d';
        } else if (emocao === "triste") {
            // Boca "Triste" (Linha reta)
            bocaPou.style.borderRadius = '5px';
            bocaPou.style.height = '6px';
            bocaPou.style.width = '40px';
            bocaPou.style.border = 'none';
            bocaPou.style.backgroundColor = '#7f1d1d';
        }
    }

    /**
     * [COMPORTAMENTO] Faz o Pou dar um saltito. (Ocioso/Reação)
     */
    function darSaltito() {
        if (containerPou.classList.contains('saltando')) return; // Já está saltando

        containerPou.classList.add('saltando');
        setTimeout(() => {
            containerPou.classList.remove('saltando');
        }, 1500); // Duração da animação de salto
    }

    /**
     * [UTILIDADE] Reseta a boca para o estado neutro (definido no HTML/CSS).
     */
    function resetarExpressao() {
        // Limpa todos os estilos inline para deixar o Tailwind (classes CSS) assumir
        bocaPou.style.borderRadius = '';
        bocaPou.style.height = '';
        bocaPou.style.width = '';
        bocaPou.style.border = '';
        bocaPou.style.borderTop = '';
        bocaPou.style.borderBottom = '';
        bocaPou.style.backgroundColor = '';
    }
    
    /**
     * [UTILIDADE] Helper para mover pupilas com transição.
     */
    function olharPara(x, y, duracaoSegundos) {
         pupilas.forEach(pupila => {
            if (!pupila) return;
            pupila.style.transition = `transform ${duracaoSegundos}s ease-in-out`;
            pupila.style.transform = `translate(${x}px, ${y}px)`;
        });
    }

    // --- Persistência e evolução autônoma ---

    function ouvirEvolucoes() {
        evolucaoRef.limitToLast(50).on('value', (snapshot) => {
            const registros = [];
            snapshot.forEach(child => {
                registros.push({ id: child.key, ...child.val() });
            });
            registros.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
            ultimaEvolucao = registros.length ? registros[registros.length - 1] : null;
            renderizarEvolucoes(registros);
        });
    }

    function registrarEvolucaoNoBanco(registro) {
        return evolucaoRef.push(registro);
    }

    function renderizarEvolucoes(registros) {
        if (!listaEvolucoes) return;
        if (!registros.length) {
            listaEvolucoes.innerHTML = '<p class="text-gray-300 text-sm">Sem evoluções ainda. Clique em "Evoluir" para começar.</p>';
            limparEvolucaoVisual();
            idUltimaEvolucaoAplicada = null;
            return;
        }

        const idMaisRecente = registros[registros.length - 1]?.id;

        listaEvolucoes.innerHTML = registros.map(registro => {
            const origem = registro.origem === 'auto' ? 'Autônomo' : 'Manual';
            const data = registro.timestamp ? formatarData(registro.timestamp) : 'Agora';
            const ativo = registro.id === idMaisRecente;
            return `
              <div class="bg-gray-900/60 p-3 rounded-2xl border ${ativo ? 'border-yellow-300/70 shadow-lg shadow-yellow-500/30 scale-[1.01]' : 'border-yellow-500/20'} transition duration-300 transform">
                <div class="flex justify-between text-[10px] text-yellow-100/80">
                  <span>${origem}</span>
                  <span>${data}</span>
                </div>
                <p class="mt-1 text-sm font-semibold text-white">${escapeHTML(registro.ideia || 'Nova expansão')}</p>
                ${registro.explicacao ? `<p class="text-xs text-yellow-100/70">${escapeHTML(registro.explicacao)}</p>` : ''}
                <pre class="mt-2 text-[11px] whitespace-pre-wrap bg-black/40 p-2 rounded-xl text-green-200 font-mono">${escapeHTML(registro.codigo || '')}</pre>
              </div>
            `;
        }).join('');

        const registroAtual = registros[registros.length - 1];
        if (registroAtual && registroAtual.id !== idUltimaEvolucaoAplicada) {
            idUltimaEvolucaoAplicada = registroAtual.id;
            aplicarEvolucaoVisual(registroAtual);
        }
    }

    function detectarTipoCodigo(codigo = '') {
        const trimmed = codigo.trim();
        if (!trimmed) return 'js';
        if (/^<style/i.test(trimmed)) return 'css';
        if (/^<script/i.test(trimmed)) return 'js';
        if (/^</.test(trimmed)) return 'html';
        const pareceCSS = /^[.#:@a-zA-Z]/.test(trimmed) && /\{[^}]+\}/.test(trimmed) && !/(function|=>|const|let|var)/.test(trimmed);
        return pareceCSS ? 'css' : 'js';
    }

    function removerTagsStyle(codigo = '') {
        return codigo.replace(/<\/?style[^>]*>/gi, '').trim();
    }

    function limparEvolucaoVisual() {
        if ((tipoEvolucaoAtiva === 'css' || tipoEvolucaoAtiva === 'js') && elementoEvolucaoAtivo && elementoEvolucaoAtivo.parentNode) {
            elementoEvolucaoAtivo.parentNode.removeChild(elementoEvolucaoAtivo);
        }
        if (tipoEvolucaoAtiva === 'html' && canvasEvolutivo) {
            canvasEvolutivo.innerHTML = conteudoCanvasInicial;
        }
        if (canvasEvolutivo) {
            canvasEvolutivo.classList.remove('ring-2', 'ring-yellow-300/60', 'shadow', 'shadow-yellow-500/20');
        }
        elementoEvolucaoAtivo = null;
        tipoEvolucaoAtiva = null;
        esconderIndicadorVisual();
        if (corpoPou) {
            corpoPou.classList.remove('evoluindo');
        }
    }

    function aplicarEvolucaoVisual(registro) {
        if (!registro || !registro.codigo) return;
        try {
            const tipo = detectarTipoCodigo(registro.codigo);
            limparEvolucaoVisual();

            if (tipo === 'css') {
                const style = document.createElement('style');
                style.dataset.evolucaoPou = registro.id || Date.now();
                style.textContent = removerTagsStyle(registro.codigo);
                document.head.appendChild(style);
                elementoEvolucaoAtivo = style;
            } else if (tipo === 'html') {
                if (canvasEvolutivo) {
                    canvasEvolutivo.innerHTML = registro.codigo;
                    canvasEvolutivo.classList.add('ring-2', 'ring-yellow-300/60', 'shadow', 'shadow-yellow-500/20');
                }
            } else {
                const script = document.createElement('script');
                script.type = 'module';
                script.textContent = registro.codigo;
                document.body.appendChild(script);
                elementoEvolucaoAtivo = script;
            }

            tipoEvolucaoAtiva = tipo;
            animarEvolucaoVisual();
            const mensagem = `Aplicando ao vivo: ${registro.ideia || 'Nova evolução'}`;
            atualizarStatusEvolucao(mensagem, true);
            mostrarIndicadorVisual(mensagem);
        } catch (error) {
            console.error('Falha ao aplicar evolução visual:', error);
            atualizarStatusEvolucao('A evolução foi salva, mas não consegui aplicá-la agora.', false);
        }
    }

    function animarEvolucaoVisual() {
        if (!corpoPou) return;
        corpoPou.classList.add('evoluindo');
        clearTimeout(animacaoEvolucaoTimer);
        animacaoEvolucaoTimer = setTimeout(() => corpoPou.classList.remove('evoluindo'), 4000);
    }

    function mostrarIndicadorVisual(texto) {
        if (!indicadorVisual) return;
        indicadorVisual.textContent = texto;
        indicadorVisual.classList.remove('hidden');
        indicadorVisual.classList.add('animate-pulse');
        clearTimeout(indicadorVisualTimer);
        indicadorVisualTimer = setTimeout(esconderIndicadorVisual, 6000);
    }

    function esconderIndicadorVisual() {
        if (!indicadorVisual) return;
        indicadorVisual.classList.add('hidden');
        indicadorVisual.classList.remove('animate-pulse');
    }

    function formatarData(timestamp) {
        return new Date(timestamp).toLocaleString('pt-BR', { hour12: false });
    }

    function escapeHTML(texto = '') {
        return texto
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    }

    function atualizarStatusEvolucao(texto, animar = false) {
        if (!statusEvolucao) return;
        statusEvolucao.textContent = texto;
        statusEvolucao.classList.toggle('animate-pulse', animar);
    }

    function gerarPromptEvolucao() {
        const contextoAnterior = ultimaEvolucao ? `Sua última ideia foi "${ultimaEvolucao.ideia}" com este trecho:\n${ultimaEvolucao.codigo}` : 'Você ainda não escreveu nenhum código para si mesmo.';
        return `Você é a Pou.IA, um mascote vivo dentro de um laboratório virtual.\n${contextoAnterior}\nCrie uma evolução incremental para suas próprias habilidades ou ambiente.\nProduza um JSON puro (sem markdown) com os campos: ideia, explicacao e codigo.\nO campo codigo deve conter no máximo 60 linhas de um trecho JavaScript, HTML ou CSS que você realmente usaria para evoluir.\nSe precisar editar código anterior, explique rapidamente no campo explicacao.`;
    }

    async function gerarCodigoAutonomo() {
        const payload = {
            contents: [{ parts: [{ text: gerarPromptEvolucao() }] }]
        };
        const resultado = await requisicaoGemini(payload);
        const candidate = resultado.candidates?.[0];
        const textoBruto = coletarTextoParts(candidate?.content?.parts);
        const json = extrairJsonDaResposta(textoBruto);
        return json;
    }

    function extrairJsonDaResposta(texto) {
        if (!texto) {
            throw new Error('Resposta vazia da IA.');
        }
        const match = texto.match(/\{[\s\S]*\}/);
        if (!match) {
            throw new Error('Estrutura JSON não encontrada.');
        }
        try {
            return JSON.parse(match[0]);
        } catch (error) {
            console.error('Falha ao converter resposta em JSON:', texto);
            throw error;
        }
    }

    async function iniciarCicloEvolutivo(origem = 'manual') {
        if (evolucaoEmAndamento) {
            atualizarStatusEvolucao('Já estou evoluindo neste momento...', true);
            return;
        }
        evolucaoEmAndamento = true;
        atualizarStatusEvolucao(origem === 'auto' ? 'Criando evolução automática sem interromper o chat...' : 'Gerando uma nova ideia para meu ambiente...', true);

        try {
            const resposta = await gerarCodigoAutonomo();
            const registro = {
                ideia: resposta.ideia || 'Evolução misteriosa',
                explicacao: resposta.explicacao || 'Sem explicação detalhada.',
                codigo: resposta.codigo || '// Não foi possível obter código',
                origem,
                timestamp: Date.now()
            };
            await registrarEvolucaoNoBanco(registro);
            ultimaEvolucao = registro;
            atualizarStatusEvolucao('Evolução salva! Continue conversando enquanto eu estudo o novo código.', false);
        } catch (error) {
            console.error('Erro ao evoluir:', error);
            atualizarStatusEvolucao('Tive um problema ao evoluir. Vou tentar novamente depois.', false);
        } finally {
            evolucaoEmAndamento = false;
        }
    }

    // --- NOVAS FUNÇÕES DA IA ---

    /**
     * Lida com o envio do formulário de chat.
     * @param {Event} e - Evento de submit.
     */
    async function lidarComEnvioChat(e) {
        e.preventDefault();
        marcarInteracaoUsuario(); // Usuário está ativo

        const promptUsuario = inputChat.value.trim();
        if (!promptUsuario) return;

        inputChat.value = '';
        inputChat.disabled = true;
        botaoEnviar.disabled = true;

        // Pou "pensa"
        mostrarBolhaFala("...", true); // true = carregando
        mudarExpressao("surpreso"); // Boca "O" de pensar
        olharPara(0, -MAX_MOVIMENTO_PUPILA / 2, 0.2); // Olha para cima pensando

        try {
            await chamarIA(promptUsuario);
        } catch (error) {
            console.error("Erro ao chamar IA:", error);
            mostrarBolhaFala("Tive um curto-circuito! Tente de novo.", false);
            resetarExpressao();
        } finally {
            // Reativa a UI
            inputChat.disabled = false;
            botaoEnviar.disabled = false;
            inputChat.focus();
        }
    }

    /**
     * Mostra ou esconde a bolha de fala.
     * @param {string} texto - O texto a ser exibido.
     * @param {boolean} [estaCarregando=false] - Aplica a animação de pulsar.
     */
    function mostrarBolhaFala(texto, estaCarregando = false) {
        clearTimeout(bolhaTimer); // Cancela o timer de sumiço anterior
        bolhaFala.innerHTML = texto;
        bolhaFala.classList.remove('hidden');
        
        if (estaCarregando) {
            bolhaFala.classList.add('carregando-bolha');
        } else {
            bolhaFala.classList.remove('carregando-bolha');
            // Esconde a bolha após 5 segundos se não estiver carregando
            bolhaTimer = setTimeout(esconderBolhaFala, 5000);
        }
    }

    /**
     * Esconde a bolha de fala e reinicia o timer de ociosidade.
     */
    function esconderBolhaFala() {
        bolhaFala.classList.add('hidden');
        // Agora que a conversa acabou, reinicia o timer para o Pou ficar ocioso
        reiniciarTimerOcioso();
    }

    /**
     * Envia o prompt para a API Gemini e processa a resposta.
     * @param {string} promptUsuario - O texto do usuário.
     */
    async function requisicaoGemini(payload) {
        let response;
        let retries = 0;
        const maxRetries = 3;
        let delay = 1000;

        while (retries < maxRetries) {
            try {
                response = await fetch(urlDaApi, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (response.ok) {
                    break; // Sucesso
                } else if (response.status === 429 || response.status >= 500) {
                    console.warn(`Tentativa ${retries + 1} falhou com status ${response.status}. Tentando novamente em ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2;
                    retries++;
                } else {
                    throw new Error(`Erro na API: ${response.statusText}`);
                }
            } catch (error) {
                console.warn(`Tentativa ${retries + 1} falhou (erro de rede). Tentando novamente em ${delay}ms...`);
                await new Promise(resolve => setTimeout(resolve, delay));
                delay *= 2;
                retries++;
            }
        }

        if (!response || !response.ok) {
            throw new Error(`Não foi possível conectar à IA após ${maxRetries} tentativas.`);
        }

        return response.json();
    }

    function coletarTextoParts(parts = []) {
        return parts.map(part => part.text || '').join('\n').trim();
    }

    async function chamarIA(promptUsuario) {
        // O prompt do sistema instrui a IA a agir como o Pou e a fornecer uma emoção
        const systemPrompt = `
          Você é o Pou, uma criatura alienígena amigável, fofa e um pouco gulosa.
          Você está vivo e conversando com seu dono.
          Responda de forma curta, divertida e simples, como o Pou.
          
          No final EXATO da sua resposta, sem pular linha, adicione uma tag de emoção.
          As emoções DEVEM ser uma destas:
          [EMOÇÃO:ALEGRE] (para respostas felizes, quando ganhar comida)
          [EMOÇÃO:TRISTE] (para respostas tristes, se estiver com fome)
          [EMOÇÃO:SURPRESO] (para perguntas inesperadas)
          [EMOÇÃO:NEUTRO] (para respostas normais)
          
          Exemplo: "Eu adoraria um biscoito! [EMOÇÃO:ALEGRE]"
          Exemplo: "Que fome... [EMOÇÃO:TRISTE]"
        `;

        const payload = {
            contents: [{ parts: [{ text: promptUsuario }] }],
            systemInstruction: {
                parts: [{ text: systemPrompt }]
            },
        };

        const result = await requisicaoGemini(payload);
        const candidate = result.candidates?.[0];

        const textoCompleto = coletarTextoParts(candidate?.content?.parts);

        if (textoCompleto) {
            analisarRespostaIA(textoCompleto);
        } else {
            console.error("Resposta da IA inválida:", result);
            analisarRespostaIA("Humm... não sei o que dizer. [EMOÇÃO:NEUTRO]");
        }
    }

    /**
     * Analisa a resposta da IA, separa o texto da emoção e aciona as reações.
     * @param {string} textoCompleto - A resposta bruta da IA (incluindo a tag).
     */
    function analisarRespostaIA(textoCompleto) {
        let emocao = "NEUTRO";
        let textoVisivel = textoCompleto;

        const regexEmocao = /\[EMOÇÃO:(\w+)\]/;
        const match = textoCompleto.match(regexEmocao);

        if (match) {
            emocao = match[1].toUpperCase();
            // Remove a tag do texto que será exibido
            textoVisivel = textoCompleto.replace(regexEmocao, '').trim();
        }

        // Mostra a fala e aciona a reação
        mostrarBolhaFala(textoVisivel, false);
        reagirComEmocao(emocao);
    }

    /**
     * Aciona a animação/expressão correspondente à emoção.
     * @param {string} emocao - "ALEGRE", "TRISTE", "SURPRESO", "NEUTRO".
     */
    function reagirComEmocao(emocao) {
        // Centraliza o olhar ao responder
        olharPara(0, 0, 0.2); 

        switch (emocao) {
            case "ALEGRE":
                darSaltito();
                mudarExpressao("sorriso");
                break;
            case "TRISTE":
                mudarExpressao("triste");
                break;
            case "SURPRESO":
                mudarExpressao("surpreso");
                break;
            case "NEUTRO":
            default:
                resetarExpressao();
                break;
        }
    }


    // --- Listeners de Eventos ---

    // Interação do Usuário (Mouse/Toque)
    document.addEventListener('mousemove', moverPupilas);
    document.addEventListener('touchmove', moverPupilas, { passive: true });
    
    // Inicia a ociosidade se o usuário nem mesmo tocou na tela
    document.addEventListener('touchstart', (e) => {
        // Apenas chama o moverPupilas para registrar a interação
        moverPupilas(e);
    }, { passive: true });

    // NOVO: Listener para o chat
    formChat.addEventListener('submit', lidarComEnvioChat);
    inputChat.addEventListener('focus', marcarInteracaoUsuario); // Para o Pou ocioso ao digitar
    botaoEvoluir.addEventListener('click', () => iniciarCicloEvolutivo('manual'));

    // Inicia o timer de ociosidade pela primeira vez
    reiniciarTimerOcioso();
    ouvirEvolucoes();
    setTimeout(() => iniciarCicloEvolutivo('auto'), 3000);
    setInterval(() => iniciarCicloEvolutivo('auto'), 120000);

    // Loop autônomo de PISCAR (sempre ativo)
    setInterval(piscarOlhos, 2000 + (Math.random() * 5000)); // Pisca a cada 2-7 segundos

  </script>

</body>
</html>